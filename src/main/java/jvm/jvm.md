jvm整体结构
main函数启动》类加载器（什么是类加载器)》jvm(存储在哪里)
java命令执行代码
    Person类》jvm.bll创建java虚拟机》创建启动类加载器（加载核心类库）》创建其他类的加载器调用getLauncher();方法
    》调用自己的getClassloader得到当前类的加载器返回loader》调用loadClass（"类名"）运行person类》加载完成jvm会执行person类的main入口Person.main();
    》结束jvm销毁

类加载器**loadClass()**;就是方法在java.lang.ClassLoader
加载》验证》准备》解析》初始化》使用》卸载
加载：在硬盘通过io读文件，只有使用的类才会被加载比如main方法和new对象等等。加载阶段会在jvm，方法区（存放person.class类信息指针）中堆生成一个代表这个类的java.lang.Class<Person>对象（反射的基础），作为方法区这个类的各种数据访问入口
验证；字节码文件的正确性，KAFABABI魔术
准备；给静态对象分配内存，赋默认值
解析；符号引用（静态方法换为指针），直接引用（就是指针），静态连接（类加载时完成换），动态连接（运行时）
初始化；静态变量初始化为指定值，执行静态代码块

加载完》在方法区》有4（反射有关）
    运行时常量池
    类型信息
    字段信息
    方法信息
    对应class实例的引用等信息；在堆里创建java.lang.Class<Person>对象（class方法调用反射）jar包中的类也是使用时才加载

类加载器和反射面试
    启动器launcher初始化（单例模式保证jvm虚拟机只有一个）》launcher创建（扩展类加载器和应用程序加载器）应用程序加载器和扩展类加载器》jvm通过getClassloader方法返回loader》
    加载器用loader方法加载类

jvm题目
    什么是类加载
    加载class二进制文件到运行时内存中的方法区（类信息）和堆（类对象）
    

加载器的**双亲委派机制**（找类）
    自定义》应用程序加载器》扩展类加载器>启动类加载器  为了防止更改核心类库 保证加载的唯一性
    加载器会先让父类先测试加载没有再让下面的加载器加载
    
    
2系统2组件
》类加载子系统
    类加载器四种（3种了在17没有扩展类加载器）
        启动类加载器；负责支持jvm运行，位于jer的lib目录rt.jar(c/c++)
        扩展类加载器：java编写，是sun.misc.Launcher的内部类ExtClassLoader类实现，负责加载lib目录中ext的jar包（扩展）
        平台类加载器；加载特定于平台的类
        应用程序加载器；java编写，Launcher的静态内部类（关键）负责加载class path路径的类包，自己写的类
        自定义类加载器；继承classloader。实现findclass（）方法（指定类的字节码加载方式），为了加载指定目录的类

常量池
    class常量池（方法区）；class文件，字面量（字符和字母和），符号引用（类名，方法名，字段名）》动态链接（运行时内存地址）
    运行时常量池（方法区）；在堆生成对象
    字符串常量池（在堆里）；性能，intern方法native
八种基本数据类型的包装类和对象池（堆里）

》运行时数据区
    堆；类对象(java.lang.Class<Person>对象)，常量，静态变量，编译后代码（栈销毁变量对象也会销毁），新生代，永久代，字符常量池
        年轻代1（811）；edan满》s0（第一次）》s1（复制算法，第二次，s0变s1）》年龄加1到15》老年代  MinerGC快
        老年代2；MajorGC/FullGC慢（调优就是减回收次数），标记整理或者清除
    方法区（运行时常量池元空间）：类信息（class文件》Person.class），
（线程独有）栈帧就是方法，把main方法压入栈底（后进先出）方法结束就出去变量销毁释放内存
    虚拟机栈；局部变量，操作数栈，动态链接，方法出口
    本地方法栈；本地方法（native）
    程序计数器；当前线程的行号（字节码的行号，跳转就要程序计数器记录）
》执行引擎（即时编译器，垃圾回收器）:执行java命令就是执行class文件，

》本地接口：和其他语言交互
》本地方法库

jvm设置
堆：-Xms 64/1；-Xmx4/1，新生代-Xmn
方法区：-XX:MetaspaceSize（最大）:-XX:MaxMetaspaceSize（gc阈值fullGc，）
栈：-Xss

启动时设置

STW


## **反射**
概念  操作类包装成对象，解耦
方法区；加载类的定义信息Person.class
堆；生成Java.lang.Class<Person> cPerson(对象)
获取方法区的类信息到堆找原数据
class类对象
field类对象
constructor类对象
method类对象

加载类对象forClass
获取类对象getClass
获取成员变量

反射应用自定义注解
    判断位置类，方法，成员变量上
    获取自定义注解
    调用自定义注解中的抽象方法获取配置属性值

jvm内存分配机制
    对象创建（需要的大小已经确定，在堆里获取）》检查类加载情况》分配内存（两种方式，指针碰撞（堆分俩分），空闲列表（有个表记录））》初始化》设置对象头》执行init();方法
    并发分配
        CAS（同步处理）；在并发编程中学习CAS加失败重试保证原子性
        本地线程分配缓存；把内存分配按照线程不同在不同空间分配提前给每个线程分配堆空间
    初始化：给对象字段赋初始值
    设置对象头；对象是哪个类的实例（）hotspot虚拟机
        对象头header；markword（运行时数据例如hashcode，年龄，锁，线程id，时间挫），类型指针，数组长度
        实例数据instance data；
        对齐填充padding；
对象栈上分配逃逸分析不会逃逸就在栈上分配对象没有被外部访问
    标量替代：就是对象分解成变量，在栈里
标量和聚合量
    标量：8基础数据
    聚合量；对象

## 内存分配机制 跳过
内存分配
对象内存回收
    堆放着对象实例（栈里也有没有引用的对象），对象死亡
    **引用计数法**（程序计数器引用就加一，用完减一，0回收）（不怎么用因为解决不了循环引用）
    **可达型分析算法**
        标记为找非垃圾对象GCRoot根节点（起点），线程栈的本地变量，静态变量，本地方法栈的变量
    **常见引用**
        强引用；普通变量引用 public static User user = new User();
        软引用；soft reference包裹 不干掉
        弱引用；包裹没有 
        虚引用
    **finalize();** 在finalizer线程中执行优先级低在f-queue队列里
        不可达算法》finalize再次标记》一个对象的finalize();方法只能执行一次》逃脱可以重写绑定其他对象》无法第二次复活
面试题：因为finalize在优先级低的线程会导致jvm内存无法即使施放导致频繁GC导致oom
面试题；如何判断类无用（方法区在）1类没有实例，2class loader回收，3类的对象没有被引用不可以通过反射访问到该类的方法
面试题；java内存oom，长生命对象有短生命对象，例如hashmap

垃圾收集算法，理论
    分代收集算法：根据对象存活周期分区选择适合的算法，新生代用复制算法，老年代没有担保
    复制算法：分两分（可用（存活，可回收），保留）
    标志整理；老年代用
    标志清除；


## 垃圾收集器
    淘汰serial收集器（单线程）；新生代用复制算法，老年标志整理 stop the word
    parallel就是serial多线程版本jdk8  算法和上米一样
    parnew区别和cms收集器配合

    cms收集器；并发收集器 初始标志会stw记录gcroots直接关联》并发标志执行开始gcroot》重新标记；解决新垃圾stw》并发清理》并发重置
    缺点：无法清理舞动垃圾（只能等待下次），用的标志清除算法

    g1收集器；面向服务器大内存g1
    zgc收集器；低延迟

cpu100%
    看内存信息
    堆信息
    stack死锁
    看运行Java程序扩展参数
    jvm参数系统参数
    cpu使用情况

看top定位错误进程》线程id》线程栈信息代码》堆中信息
    



        